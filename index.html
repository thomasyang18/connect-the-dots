<!DOCTYPE html>
<html>
<head>
    <title>Connect the Dots</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="top-container">
        <div class="achievements">
            <div id="achievements">
                <!-- Achievements will be loaded here -->
            </div>
        </div>
    </div>

    <div id="canvas-container" style="display: flex; align-items: center; justify-content: center; padding-top: 10px; width: 100vw">
        <div id="hints-div" style="display: grid; width: 45vw; background-color: #f0f0f0; border-radius: 10px; padding: 10px; margin: 5px; transition: opacity 0.5s;">
            <!-- Hints will be loaded here -->
        </div>

        <div id="dev-message-div" style="display: none; width: 45vw; justify-content : 'flex-start'; background-color: #f0f0f0; border-radius: 10px; margin: 5px; padding: 10px; transition: opacity 0.5s;">
            <!-- Dev message will be loaded here -->
            <center><h1>Hello! Dev here.</h1></center>
            <p>This is a competitive programming problem. Pretty neat, right? </p>
            <p>
                This problem is problem K, "Connect the Dots", from <b>2022-2023 Winter Petrozavodsk Camp, Day 2: GP of ainta</b>.
                The link to the problem is <a href="https://codeforces.com/gym/104427/problem/K" target="_blank">here</a>; 
                you definitely look it up online if this link ceases to work. Try writing some code to solve this! This game 
                just provided the general algorithm: can you optimize the steps to O(n)? :)
            </p>
            <hr>
            <p>
                The main point of this project was to try and really show what goes on in someone's brain and how they could've come up with this solution.
                I think specifically, the line of thought:  
            </p>

            <ul>
                <li>'Global' connections are hard to think about. Let's try to think about local connections first. (Make those blue triangles!) </li>
                <li>Hmm. Well, something immidiately obvious is that if there's 1 node of a certain color left, we can hook it up to the rest - there cannot be any conflicts.</li>
                <li>Okay, so let's say we have 3 colors. Hmm. Well, (r, g, b) can be collapsed. (r, r, b) can be collapsed. </li>
            </ul> 

            <p>And the point is that these relatively simple, almost obvious observations are enough to solve the problem! </p>

            <p>(Haha, if you were thrown off by the terseness of observation 14, sorry! I would have to show this entire proof to show why it works.)</p>

            <p>Then the crucial step: If <b>no subarray looks like those</b>, then we're pigeonholed into trying a sequence (a, b, a, b....).</p>

            <p><b>
                But this will inevitably fail because there are three colors in the array! 
            </b> You can never have an infinite repeating sequence like this, <b>as long as you maintain 3 colors are in the array.</b> 
            </p>

            <p>Well, shucks, that's the same problem we ran into for the n=13 case; there was only 1 red node, and we would've deleted it, 
                following the wrong algorithm.  
            </p>
            <p>
                <b>BUT!</b> If I went down to 2 distinct colors after an operation => I only had 1 count of a certain color => 
                We can hook that color up to every other node => We can avoid the bad case entirely. </p>

            <p>So it actually doesn't matter; just swap the priorities, so you always check for the edge case first. </p>

            <p> So you can always find a correct reduction of moves. Pretty cool, right? </p>

            <hr>
            <p>
                Of course, there's a <b>lot</b> going on behind the scenes - I <a href="https://codeforces.com/gym/104427/problem/K" target="_blank">highly reccomend trying to solve the original problem</a>, 
                and comparing its original problem statement to this one. Although they are equivalent, there are plenty of assumptions and 
                reductions you would have to make. 
            </p>
            <p>
                Nevertheless, I would consider this the 'core' of the proof, regardless. At the very least, reducing it to this form 
                is probably the most reasonable for a general audience.
            </p>
            <hr>
            <p>
                It's this very niche but very fun mix of both math and computer science that is so great about competitive programming. 
                It also is profoundly useless. 
            </p>
            <p>
                The most ivory of pure math researchers can't learn from this algorithm. 
                Theoretical computer scientists are too busy tackling fundamental problems, like shortest paths and flow.  
                Don't even get me started on the engineers. 
            </p>
            <p>
                Nevertheless, these brain teasers are what consumed my life for the past half-decade :) 
            </p>
            <!-- <p>
                I'm still simplifying a lot here. For example, for me, I did not intuitively think about local connections - instead, I tried "global" ones first and recursing down.
                But once you show that 2n - 3 edges can maximally exist, looking for 'local' connections becomes more intuitive. Just a little bit. Reducing it to a polygon and proving correctness with lower/upper bounds isn't trivial.
                In fact, when we were solving this problem, 
                I never realized that we could interpret it as a polygon - all of our reductions were on the original array.
            </p>
            <p>
                Me and my friend wrote brute forcers and combined many observations to get to the final algorithm (which involved a lot of linked list shenanigans). 
                The line of thought definitely was not as clean as presented in the chat, or here. 
                As soon as my friend put out the idea that 3 colors was sufficient to achieve the polygonal bound though (still a pretty crazy idea), 
                this line of proof naturally came out.
            </p>
            <p>
                Of course, this isn't the only way to think about it - there are plenty, plenty of ways to think about it. Nevertheless, having this little game is fun :D 
            </p> -->

            <button id="close-dev-message">Return to Game</button>
        </div>
        <canvas id="canvas" width="800%" height="800%"></canvas>
    </div>

    <script type="module" src="main.js"></script>
</body>
</html>
